# internal/executor - Command Execution

## Overview

The `executor` package is responsible for safely executing shell commands generated by the LLM. It handles cross-platform shell detection, command execution, and output streaming while maintaining security and user safety.

## Architecture

### Core Function

```go
// Execute runs a shell command and returns the output
func Execute(command string) error
```

**Key Responsibilities**:
1. Detect the appropriate shell (bash, zsh, sh, cmd.exe)
2. Execute command in user's shell context
3. Stream output directly to user's terminal
4. Handle errors and return execution status

### Execution Flow

```
Command: "find . -name '*.go'"
        ↓
Detect OS and Shell
        ↓
Build exec.Command:
  Unix: /bin/zsh -c "find . -name '*.go'"
  Windows: cmd /C "find . -name '*.go'"
        ↓
Connect stdin/stdout/stderr
        ↓
Run command
        ↓
Stream output to terminal
        ↓
Return error (if any)
```

## Implementation Details

### Shell Detection

**Unix-like Systems** (macOS, Linux):
```go
shell := os.Getenv("SHELL")  // "/bin/zsh", "/bin/bash", "/bin/fish", etc.
if shell == "" {
    shell = "/bin/sh"  // Fallback to POSIX shell
}
cmd := exec.Command(shell, "-c", command)
```

**Windows**:
```go
cmd := exec.Command("cmd", "/C", command)
```

**Why `-c` flag?**
- Executes command string as a single argument
- Allows complex commands with pipes, redirects, etc.
- Preserves shell features (wildcards, variables, etc.)

### I/O Handling

```go
cmd.Stdin = os.Stdin    // Allow interactive commands (e.g., vim, less)
cmd.Stdout = os.Stdout  // Stream output directly to terminal
cmd.Stderr = os.Stderr  // Stream errors directly to terminal
```

**Benefits**:
- **Interactive Commands**: Commands like `vim`, `less`, `top` work correctly
- **Real-time Output**: User sees output as it happens (not buffered)
- **Colors Preserved**: ANSI colors pass through to terminal
- **Signal Handling**: Ctrl+C works as expected

### Error Handling

```go
if err := cmd.Run(); err != nil {
    return fmt.Errorf("command failed: %w", err)
}
```

**Exit Code Handling**:
- Non-zero exit code → error returned
- Main.go displays error to user
- User sees command's stderr output

## Security Considerations

### Command Injection (Mitigated by Design)

**Risk**: Shell metacharacters could be exploited
```go
// Dangerous if user input was directly concatenated:
command := "ls " + userInput  // If userInput = "; rm -rf /", disaster!
```

**Our Mitigation**:
1. **LLM Generates Full Command**: User doesn't directly provide command strings
2. **User Review Required**: User sees and approves exact command before execution
3. **No String Concatenation**: Commands come from LLM as complete strings

**Remaining Risk**: LLM could be prompt-injected to generate malicious commands
**Final Defense**: User must review and approve every command

### Dangerous Command Patterns

**Currently Allowed** (relies on user review):
- `rm -rf /path`: File deletion
- `dd if=X of=Y`: Disk operations
- `mkfs`: Filesystem formatting
- `sudo ...`: Privileged operations
- `chmod 777`: Permission changes

**Future Enhancement**: Pattern detection and warnings

```go
// Proposed: Add safety checks before execution
func CheckSafety(command string) (safe bool, warning string) {
    dangerousPatterns := []struct {
        pattern string
        warning string
    }{
        {`rm\s+-rf\s+/`, "⚠️  DANGER: Recursively deleting from root!"},
        {`dd\s+.*of=/dev/`, "⚠️  DANGER: Writing to block device!"},
        {`mkfs`, "⚠️  DANGER: Formatting filesystem!"},
    }

    for _, p := range dangerousPatterns {
        if matched, _ := regexp.MatchString(p.pattern, command); matched {
            return false, p.warning
        }
    }

    return true, ""
}

// In Execute():
if safe, warning := CheckSafety(command); !safe {
    fmt.Println(warning)
    if !ui.ExtraConfirm("Are you ABSOLUTELY SURE?") {
        return fmt.Errorf("execution cancelled by user")
    }
}
```

### Privilege Escalation

**Risk**: Commands with `sudo` execute with elevated privileges

**Current Handling**:
- Commands show `sudo` in preview
- User's sudo password required (not stored)
- User makes final decision

**Best Practice**: Warn about sudo usage
```go
if strings.Contains(command, "sudo") {
    ui.ShowWarning("⚠️  Command requires elevated privileges (sudo)")
}
```

### Environment Variables

**Current Behavior**: Commands inherit user's environment
```go
// Inherits from parent process
cmd.Env = nil  // Uses os.Environ() by default
```

**Security Implications**:
- `PATH`: Command resolution uses user's PATH
- `HOME`: Access to user's home directory
- API keys, tokens in environment are accessible to commands

**Generally Safe**: Commands run with user's privileges anyway

### File System Access

**No Sandboxing**: Commands have full access to filesystem
- Read/write user's files
- Access network
- Modify system (if permissions allow)

**Mitigation**: User review + approval

**Future Enhancement**: Optional sandbox mode
```go
// Proposed: Run in restricted environment
func ExecuteSandboxed(command string) error {
    // Use Docker, firejail, or similar
    // Limit filesystem access
    // Limit network access
    // Limit resources
}
```

## Cross-Platform Compatibility

### Platform Differences

| Feature | Unix/macOS | Windows | Notes |
|---------|------------|---------|-------|
| Shell | `$SHELL` or `/bin/sh` | `cmd.exe` | Detect with `runtime.GOOS` |
| Shell Flag | `-c` | `/C` | Different syntax |
| Path Separator | `/` | `\` | Use `filepath` package |
| Line Endings | `\n` | `\r\n` | Usually handled by shell |
| Executables | `chmod +x` | `.exe` extension | Different conventions |
| Case Sensitivity | Yes (Linux), No (macOS default) | No | Be aware for scripts |

### Shell Variations (Unix)

**Common Shells**:
- `/bin/bash`: Bash (most common on Linux)
- `/bin/zsh`: Zsh (default on macOS Catalina+)
- `/bin/fish`: Fish (alternative shell)
- `/bin/sh`: POSIX shell (minimal, portable)

**Compatibility Strategy**:
1. **Use User's Shell**: `$SHELL` env var respects user preference
2. **Fallback to `/bin/sh`**: POSIX-compliant, always available
3. **Prompt Engineering**: LLM generates portable commands when possible

**Shell-Specific Features**:
```bash
# Bash/Zsh specific
find . -name "*.go" -exec {} \;

# More portable (POSIX)
find . -name "*.go" | xargs ...
```

**Recommendation**: Guide LLM toward POSIX-compatible commands

### Testing Cross-Platform

```go
// Use build tags for platform-specific tests
//go:build !windows
// +build !windows

func TestExecute_UnixShell(t *testing.T) {
    // Test Unix shell detection
}

//go:build windows
// +build windows

func TestExecute_WindowsCmd(t *testing.T) {
    // Test Windows cmd.exe
}
```

## Error Handling Patterns

### Command Execution Errors

**Types of Errors**:
1. **Command Not Found**: Exit code 127 (Unix) or similar
2. **Permission Denied**: Exit code 126 or error from OS
3. **Command Failed**: Non-zero exit code
4. **Signal Termination**: Command killed by signal

**Current Handling**:
```go
if err := cmd.Run(); err != nil {
    return fmt.Errorf("command failed: %w", err)
}
```

**Enhanced Handling**:
```go
func Execute(command string) error {
    // ... setup cmd ...

    if err := cmd.Run(); err != nil {
        // Check exit code
        if exitError, ok := err.(*exec.ExitError); ok {
            exitCode := exitError.ExitCode()
            switch exitCode {
            case 127:
                return fmt.Errorf("command not found: %w", err)
            case 126:
                return fmt.Errorf("permission denied: %w", err)
            default:
                return fmt.Errorf("command failed with exit code %d: %w", exitCode, err)
            }
        }

        // Other errors (e.g., couldn't start command)
        return fmt.Errorf("failed to execute command: %w", err)
    }

    return nil
}
```

### User Interruption

**Ctrl+C Handling**:
```go
// Current: Signals propagate to child process
// Command receives SIGINT, can handle appropriately
```

**Future: Graceful Cleanup**
```go
func ExecuteWithCleanup(command string) error {
    cmd := /* ... */

    // Handle interrupts
    sigChan := make(chan os.Signal, 1)
    signal.Notify(sigChan, os.Interrupt)

    go func() {
        <-sigChan
        // Graceful shutdown
        cmd.Process.Signal(os.Interrupt)
        time.Sleep(5 * time.Second)
        cmd.Process.Kill()
    }()

    return cmd.Run()
}
```

## Testing Strategy

### Safe Test Commands

**Good Test Commands** (safe, deterministic):
```go
"echo hello"              // Simple output
"true"                    // Exit 0
"false"                   // Exit 1
"printf 'test\\n'"        // Formatted output
"[ -d /tmp ]"             // Conditional (should pass)
```

**Avoid in Tests**:
```go
"rm -rf /tmp/test"        // Destructive
"sleep 100"               // Slow
"curl https://..."        // Network dependency
"sudo ..."                // Requires privileges
```

### Mock Execution

```go
// For testing code that calls Execute()
type MockExecutor struct {
    CommandsRun []string
    ShouldError bool
}

func (m *MockExecutor) Execute(command string) error {
    m.CommandsRun = append(m.CommandsRun, command)
    if m.ShouldError {
        return fmt.Errorf("mock error")
    }
    return nil
}

// Use in tests:
mockExec := &MockExecutor{}
// ... run test ...
if len(mockExec.CommandsRun) != 1 {
    t.Errorf("expected 1 command, got %d", len(mockExec.CommandsRun))
}
```

### Test Cases

```go
func TestExecute_Success(t *testing.T) {
    err := Execute("echo test")
    if err != nil {
        t.Errorf("unexpected error: %v", err)
    }
}

func TestExecute_Failure(t *testing.T) {
    err := Execute("false")  // Exit code 1
    if err == nil {
        t.Error("expected error, got nil")
    }
}

func TestExecute_NotFound(t *testing.T) {
    err := Execute("nonexistent-command-12345")
    if err == nil {
        t.Error("expected error for non-existent command")
    }
}

func TestExecute_ShellDetection_Unix(t *testing.T) {
    // Test that $SHELL is respected
    os.Setenv("SHELL", "/bin/bash")
    defer os.Unsetenv("SHELL")

    // Execute should use bash
    err := Execute("echo $0")  // Should print "bash"
    // ... verify ...
}
```

## Performance Considerations

### Execution Overhead

**Latency Breakdown**:
1. **Shell Startup**: ~10-50ms (depends on shell, rc files)
2. **Command Execution**: Varies by command
3. **Output Streaming**: Real-time (no buffering delay)

**Total**: Negligible overhead for most commands

### Optimization Opportunities

**Current**: Each command spawns new shell
```go
Execute("ls") → /bin/zsh -c "ls"
Execute("pwd") → /bin/zsh -c "pwd"
```

**Alternative**: Persistent shell session (future)
```go
// Reuse shell across commands
type ShellSession struct {
    stdin  io.WriteCloser
    stdout io.ReadCloser
    stderr io.ReadCloser
}

func (s *ShellSession) Execute(command string) error {
    // Write to stdin, read from stdout
    // Faster for multiple commands
}
```

**Tradeoff**: Complexity vs. performance gain (minimal for `please` use case)

## Future Enhancements

### Short-term
- [ ] Add dangerous command pattern detection
- [ ] Enhanced error messages with exit codes
- [ ] Warning for sudo commands
- [ ] Dry-run mode (show what would execute)

### Medium-term
- [ ] Command timeout support
- [ ] Output capture option (for history/analysis)
- [ ] Sandbox mode (Docker/firejail)
- [ ] Streaming progress indicators

### Long-term
- [ ] Persistent shell sessions
- [ ] Command replay from history
- [ ] Undo/rollback support (for safe commands)
- [ ] Remote execution (SSH)

## Common Patterns

### Capturing Output (When Needed)

```go
func ExecuteWithOutput(command string) (string, error) {
    var shell string
    if runtime.GOOS == "windows" {
        shell = "cmd"
    } else {
        shell = os.Getenv("SHELL")
        if shell == "" {
            shell = "/bin/sh"
        }
    }

    var stdout bytes.Buffer
    cmd := exec.Command(shell, "-c", command)
    cmd.Stdout = &stdout
    cmd.Stderr = os.Stderr  // Still show errors

    if err := cmd.Run(); err != nil {
        return "", err
    }

    return stdout.String(), nil
}
```

**Use Case**: Command suggestions based on output

### Timeout Support

```go
func ExecuteWithTimeout(command string, timeout time.Duration) error {
    ctx, cancel := context.WithTimeout(context.Background(), timeout)
    defer cancel()

    var shell string
    if runtime.GOOS == "windows" {
        shell = "cmd"
    } else {
        shell = os.Getenv("SHELL")
        if shell == "" {
            shell = "/bin/sh"
        }
    }

    cmd := exec.CommandContext(ctx, shell, "-c", command)
    cmd.Stdin = os.Stdin
    cmd.Stdout = os.Stdout
    cmd.Stderr = os.Stderr

    err := cmd.Run()
    if ctx.Err() == context.DeadlineExceeded {
        return fmt.Errorf("command timed out after %v", timeout)
    }

    return err
}
```

**Use Case**: Prevent hanging commands

### Working Directory Control

```go
func ExecuteInDirectory(command string, dir string) error {
    // ... setup cmd ...
    cmd.Dir = dir  // Set working directory
    return cmd.Run()
}
```

**Use Case**: Execute in specific project directory

## Quick Reference

### Execute Simple Command
```go
err := Execute("ls -la")
```

### Check for Specific Error
```go
err := Execute("false")
if err != nil {
    if strings.Contains(err.Error(), "exit status 1") {
        // Handle specific error
    }
}
```

### Test Command Safely
```go
// Good for tests - safe, fast, deterministic
Execute("echo test")
Execute("true")
Execute("printf 'output\\n'")
```

### Detect Platform
```go
if runtime.GOOS == "windows" {
    // Windows-specific
} else {
    // Unix-like
}
```

## Security Checklist

When modifying executor:

- [ ] Never bypass user confirmation
- [ ] Always show full command to user
- [ ] Don't store/log sensitive command output (passwords, keys)
- [ ] Consider adding command allowlist/denylist
- [ ] Validate command format (basic sanity check)
- [ ] Handle errors gracefully
- [ ] Test cross-platform behavior
- [ ] Document security implications

## Related Documentation

- **Root CLAUDE.md**: Overall architecture and security model
- **internal/agent/CLAUDE.md**: How commands are generated
- **README.md**: User-facing safety information
